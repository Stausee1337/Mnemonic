import { 
    VirtualElement,
    Instance,
    Placement,
    State as PopperState,
    Options,
    Modifier,
    createPopper
} from '@popperjs/core'
import { useCallback, useRef, useState, useMemo } from 'preact/hooks'

export interface UsePopperState {
    placement: Placement;
    update: () => void;
    forceUpdate: () => void;
    styles: Record<string, Partial<CSSStyleDeclaration>>;
    state?: PopperState;
}

export type UsePopperOptions = Omit<
  Options,
  'modifiers' | 'placement' | 'strategy'
> & {
  enabled?: boolean;
  placement?: Options['placement'];
  strategy?: Options['strategy'];
  // modifiers?: Options['modifiers'];
};

export function usePopper(
    referenceElement: VirtualElement | null,
    popperElement: HTMLElement | null, 
    {
        enabled = true,
        placement = 'bottom',
        strategy = 'absolute',
        ...config
    }: UsePopperOptions = {}
) {
    const popperInstanceRef = useRef<Instance>();

    const update = useCallback(() => {
        popperInstanceRef.current?.update();
    }, []);

    const forceUpdate = useCallback(() => {
        popperInstanceRef.current?.forceUpdate();
    }, []);

    const [popperState, setState] = useState<UsePopperState>({
        placement,
        update,
        forceUpdate,
        styles: {
            popper: {},
            arrow: {}
        }
    })

    const updateModifier = useMemo<Modifier<'updateStateModifier', any>>(
        () => ({
          name: 'updateStateModifier',
          enabled: true,
          phase: 'write',
          requires: ['computeStyles'],
          fn: ({ state }) => {
            const styles: UsePopperState['styles'] = {};
            // const attributes: UsePopperState['attributes'] = {};
    
            Object.keys(state.elements).forEach((element) => {
              styles[element] = state.styles[element];
              // attributes[element] = state.attributes[element];
            });
    
            setState({
              state,
              styles,
              // attributes,
              update,
              forceUpdate,
              placement: state.placement,
            });
          },
        }),
        [update, forceUpdate, setState],
      );
    
      const nextModifiers = useMemo(() => {
        if (prevModifiers.current !== modifiers) {
          prevModifiers.current = modifiers;
        }
        return prevModifiers.current!;
      }, [modifiers]);
    
      useEffect(() => {
        if (!popperInstanceRef.current || !enabled) return;
    
        popperInstanceRef.current.setOptions({
          placement,
          strategy,
          modifiers: [
            ...nextModifiers,
            updateModifier,
          ],
        });
      }, [strategy, placement, updateModifier, enabled, nextModifiers]);
    
      useEffect(() => {
        if (!enabled || referenceElement == null || popperElement == null) {
          return undefined;
        }
    
        popperInstanceRef.current = createPopper(referenceElement, popperElement, {
          ...config,
          placement,
          strategy,
          modifiers: [...nextModifiers, updateModifier],
        });
    
        return () => {
          if (popperInstanceRef.current != null) {
            popperInstanceRef.current.destroy();
            popperInstanceRef.current = undefined;
    
            setState((s) => ({
              ...s,
              attributes: {},
              styles: { popper: {} },
            }));
          }
        };
        // This is only run once to _create_ the popper
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [enabled, referenceElement, popperElement]);
}
